// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "go_asm.h"
#include "go_tls.h"
#include "textflag.h"
#include "syscall_noos.h"
#include "asm_riscv64.h"


// func cpuid() int
TEXT ·cpuid(SB),NOSPLIT|NOFRAME,$0
	CSRR  (MHARTID, a0)
	MOV   A0, ret+0(FP)
	RET

// The RISC-V Instruction Set Manual Volume II: Privileged Architecture defines
// the following decreasing interrupt priority order:
//
// MEI, MSI, MTI, SEI, SSI, STI, UEI, USI, UTI
//
// That's a hardware priority order conclusive in case of multiple simultaneous
// pending interrupts provided that all are enabled in the mie register.
//
// The trapHandler supports nested interrupts and implements slightly different
// software order using mie register to mask lower priority interrupts:
//
// MEI, MTI, MSI
//
// We don't support supervisor or user mode interrupts.

#define SYS_MAX_ARGS (24+8)
#define GPRS_SIZE (27*8)
#define FPRS_SIZE (33*8)
#define TRAP_CTX_SIZE (3*8+2*8)

#define SAVE_GPRS(base, offset) \
	MOV  LR, (0*8+offset)(base) \
	\    // X2 saved in cpuctx.gh.sched.sp
	MOV  GP, (1*8+offset)(base) \
	\    // g saved in cpuctx.gh.sched.g
	MOV  T0, (2*8+offset)(base) \
	MOV  T1, (3*8+offset)(base) \
	MOV  T2, (4*8+offset)(base) \
	MOV  S0, (5*8+offset)(base) \
	MOV  S1, (6*8+offset)(base) \
	\    // A0 saved before
	\    // A1 saved before
	MOV  A2, (7*8+offset)(base) \
	MOV  A3, (8*8+offset)(base) \
	MOV  A4, (9*8+offset)(base) \
	MOV  A5, (10*8+offset)(base) \
	MOV  A6, (11*8+offset)(base) \
	MOV  A7, (12*8+offset)(base) \
	MOV  S2, (13*8+offset)(base) \
	MOV  S3, (14*8+offset)(base) \
	MOV  S4, (15*8+offset)(base) \
	MOV  S5, (16*8+offset)(base) \
	MOV  S6, (17*8+offset)(base) \
	MOV  S7, (18*8+offset)(base) \
	MOV  S8, (19*8+offset)(base) \
	MOV  S9, (20*8+offset)(base) \
	MOV  S10, (21*8+offset)(base) \
	MOV  S11, (22*8+offset)(base) \
	MOV  T3, (23*8+offset)(base) \
	MOV  T4, (24*8+offset)(base) \
	MOV  T5, (25*8+offset)(base) \
	MOV  T6, (26*8+offset)(base)  // must be in sync with GPRS_SIZE

#define SAVE_FPRS(base, offset, scr, scn) \
	MOVD  F0, (0*8+offset)(base) \
	MOVD  F1, (1*8+offset)(base) \
	MOVD  F2, (2*8+offset)(base) \
	MOVD  F3, (3*8+offset)(base) \
	MOVD  F4, (4*8+offset)(base) \
	MOVD  F5, (5*8+offset)(base) \
	MOVD  F6, (6*8+offset)(base) \
	MOVD  F7, (7*8+offset)(base) \
	MOVD  F8, (8*8+offset)(base) \
	MOVD  F9, (9*8+offset)(base) \
	MOVD  F10, (10*8+offset)(base) \
	MOVD  F11, (11*8+offset)(base) \
	MOVD  F12, (12*8+offset)(base) \
	MOVD  F13, (13*8+offset)(base) \
	MOVD  F14, (14*8+offset)(base) \
	MOVD  F15, (15*8+offset)(base) \
	MOVD  F16, (16*8+offset)(base) \
	MOVD  F17, (17*8+offset)(base) \
	MOVD  F18, (18*8+offset)(base) \
	MOVD  F19, (19*8+offset)(base) \
	MOVD  F20, (20*8+offset)(base) \
	MOVD  F21, (21*8+offset)(base) \
	MOVD  F22, (22*8+offset)(base) \
	MOVD  F23, (23*8+offset)(base) \
	MOVD  F24, (24*8+offset)(base) \
	MOVD  F25, (25*8+offset)(base) \
	MOVD  F26, (26*8+offset)(base) \
	MOVD  F27, (27*8+offset)(base) \
	MOVD  F28, (28*8+offset)(base) \
	MOVD  F29, (29*8+offset)(base) \
	MOVD  F30, (30*8+offset)(base) \
	MOVD  F31, (31*8+offset)(base) \
	CSRR  (FCSR, scn) \
	MOV   scr, (32*8+offset)(base)  // must be in sync with FPRS_SIZE


TEXT runtime·trapHandler(SB),NOSPLIT|NOFRAME,$0
	// At this point the interrupts are globaly disabled (mstatus.MIE=0).
	// We want to enable higher priority interrupts as soon as possible.
	// Be carefult to don't clobber T6 (REGTMP) and A3-A5 (syscall args).

	// MSCRATCH contains &cpuctx if trap from thread mode, 0 for nested trap
	CSRRW  (a0, MSCRATCH, a0)  // swap A0 with cpuctx in MSCRATCH
	BEQ    ZERO, A0, gAndSPReady

	// setup g and SP for handler mode, save thread ones to cpuctx.gh.sched.sp
	MOV  X2, (g_sched+gobuf_sp)(A0)
	MOV  g, (g_sched+gobuf_g)(A0)
	MOV  (g_stack+stack_hi)(A0), X2
	MOV  A0, g
	
gAndSPReady:
	// g and SP are ready, A0 can be used for further processing

	//  free another register (A1) and save trap context
	ADD   $-TRAP_CTX_SIZE, X2
	MOV   A1, 8(X2)
	CSRR  (MIE, a1)
	MOV   A1, 16(X2)
	CSRR  (MSTATUS, a1)
	MOV   A1, 24(X2)
	SLTU  A0, ZERO, A1  // calculate FROM_THREAD flag
	CSRR  (MEPC, a0)
	OR    A1, A0
	MOV   A0, 32(X2)  // must be in sync with TRAP_CTX_SIZE
	CSRR  (MCAUSE, a0)
	//MOV   A0, 40(X2) // not needed yet (necessary to support local interruts)

	// syscall handling code expects A0=MCAUSE, A1=FROM_THREAD
	BGE  A0, ZERO, exception

	// save original A0 content
	CSRRWI  (0, MSCRATCH, a1)  // set MSCRATCH=0
	MOV     A1, (X2)

	// mask same or lower priority interrupts
	MOV   $-2, A1
	SLL   A0, A1  // only 6 lower bits of A0 (MCAUSE) are used as shift amount
	CSRR  (MIE, a0)
	AND   A1, A0
	CSRW  (a0, MIE)

	// enable interrupts
	CSRSI  (8, MSTATUS)  // set MSTATUS.MIE=1

	// software interrupt runs thread scheduler which save registers in m.mOS
	MOV  $(-2<<3), A0
	BEQ  A0, A1, softwareInterrupt

	// save all registers on the handler stack
	SAVE_GPRS  (X2, 0)
	SAVE_FPRS  (X2, GPRS_SIZE, A0, a0)

	// dispatch two remaining known cases
	SLL  $4, A0
	BEQ  A0, A1, timerInterrupt
	SLL  $4, A0
	BEQ  A0, A1, externalInterrupt

	// unknown interrupt
	EBREAK
	JMP  -1(PC)


softwareInterrupt:


timerInterrupt:


externalInterrupt:


exception:
	MOV $2, A1
	BNE A1, A0, 
	
	// illegal instruction
	CSRR  (MEPC, a0)
	MOV (A0), A1	// load the instruction
	MOV $~(0x1F<<7), A0

	// system call: 8 <= mcause <= 11
	SRL  $2, A0
	BNE  A1, A0, otherFault

	CSRWI  (0, MSCRATCH)  // set MSCRATCH=0

	// mask software interrupts
	CSRR  (MIE, a0)
	AND   $(-2<<3), A0
	CSRW  (a0, MIE)

	// enable interrupts
	CSRSI  (8, MSTATUS)  // set mstatus.MIE=1

	// System call is like oridnary function call so all registers except LR are
	// caller save (Go ABI0). The tiny wrappers over ECALL instruction add
	// additional parameters in A3-A5 registers.

	MOV  LR, 8(X2)

	// A1: FROM_THREAD flag
	// A3: syscall number
	// A4: argument data size on the stack (+8 for frame-pointer)
	// A5: return data size on the stack

	// check the syscall number
	MOV   $SYS_NUM, A0
	BGEU  A3, A0, badSyscall

	// determine the caller stack
	BEQ   ZERO, A1, 2(PC)
	MOV   (g_sched+gobuf_sp)(g), A0  // saved stack if call from thread mode
	JMP   4(PC)
	MOV   $SYS_LAST_FAST, A0
	BLTU  A0, A3, badHandlerCall
	ADD   $TRAP_CTX_SIZE, X2, A0  // current stack if call from handler mode:

	// make a space on the stack for arguments + 3 registers
	ADD  $-(SYS_MAX_ARGS+3*8), X2

	// copy arguments from the caller's stack
	MOV   $·duffcopy+2048(SB), A2
	SLL   $1, A4
	SUB   A4, A2
	MOV   X2, A1
	CALL  A2

	// save data needed to copy the return values back to the caller's stack
	ADD  $SYS_MAX_ARGS, X2, A2
	MOV  A0, (0*8)(A2)
	MOV  A1, (1*8)(A2)
	MOV  A5, (2*8)(A2)

	// call the service routine
	MOV   $·syscalls(SB), A0
	SLL   $3, A3
	ADD   A3, A0
	MOV   (A0), A0
	CALL  A0

	// copy the return values back to the caller's stack
	MOV   (SYS_MAX_ARGS+2*8)(X2), A4
	BEQ   ZERO, A4, nothingToCopy
	MOV   (SYS_MAX_ARGS+0*8)(X2), A1
	MOV   (SYS_MAX_ARGS+1*8)(X2), A0
	MOV   $·duffcopy+2048(SB), A2
	SLL   $1, A4
	SUB   A4, A2
	CALL  A2
nothingToCopy:

	// pop everything from the stack
	ADD  $(SYS_MAX_ARGS+3*8), X2
	MOV  8(X2), LR
	MOV  16(X2), A0  // MIE
	MOV  24(X2), A1  // MSTATUS
	SLL  $(64-12), A1
	SRL  $(64-12), A1
	MOV  32(X2), A2  // MEPC
	ADD  $4, A2      // points back to ECALL, adjust it
	ADD  $TRAP_CTX_SIZE, X2

	// disable interrupts
	CSRRCI  (8, MSTATUS, a3)

	// restore trap context
	CSRW  (a0, MIE)
	SRL   $12, A3
	SLL   $12, A3
	OR    A1, A3
	CSRW  (a3, MSTATUS)
	CSRW  (a2, MEPC)

	// restore thread g and SP
	AND   $1, A2  // FROM_THREAD flag
	BEQ   ZERO, A2, 4(PC)
	MOV   (g_sched+gobuf_sp)(g), X2
	CSRW  (G, MSCRATCH)
	MOV   (g_sched+gobuf_g)(g), g

	MRET


badSyscall:
	EBREAK  // bad syscall number
	JMP     -1(PC)

badHandlerCall:
	EBREAK  // syscall not allowed in handler mode
	JMP     -1(PC)

otherFault:
	EBREAK  
	JMP     -1(PC)
